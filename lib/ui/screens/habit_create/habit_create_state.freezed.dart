// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'habit_create_state.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$HabitCreateState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() idle,
    required TResult Function() progress,
    required TResult Function() success,
    required TResult Function() error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? idle,
    TResult? Function()? progress,
    TResult? Function()? success,
    TResult? Function()? error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? idle,
    TResult Function()? progress,
    TResult Function()? success,
    TResult Function()? error,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(HabitCreateIdle value) idle,
    required TResult Function(HabitCreateProgress value) progress,
    required TResult Function(HabitCreateSuccess value) success,
    required TResult Function(HabitCreateError value) error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(HabitCreateIdle value)? idle,
    TResult? Function(HabitCreateProgress value)? progress,
    TResult? Function(HabitCreateSuccess value)? success,
    TResult? Function(HabitCreateError value)? error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(HabitCreateIdle value)? idle,
    TResult Function(HabitCreateProgress value)? progress,
    TResult Function(HabitCreateSuccess value)? success,
    TResult Function(HabitCreateError value)? error,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $HabitCreateStateCopyWith<$Res> {
  factory $HabitCreateStateCopyWith(
          HabitCreateState value, $Res Function(HabitCreateState) then) =
      _$HabitCreateStateCopyWithImpl<$Res, HabitCreateState>;
}

/// @nodoc
class _$HabitCreateStateCopyWithImpl<$Res, $Val extends HabitCreateState>
    implements $HabitCreateStateCopyWith<$Res> {
  _$HabitCreateStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$HabitCreateIdleImplCopyWith<$Res> {
  factory _$$HabitCreateIdleImplCopyWith(_$HabitCreateIdleImpl value,
          $Res Function(_$HabitCreateIdleImpl) then) =
      __$$HabitCreateIdleImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$HabitCreateIdleImplCopyWithImpl<$Res>
    extends _$HabitCreateStateCopyWithImpl<$Res, _$HabitCreateIdleImpl>
    implements _$$HabitCreateIdleImplCopyWith<$Res> {
  __$$HabitCreateIdleImplCopyWithImpl(
      _$HabitCreateIdleImpl _value, $Res Function(_$HabitCreateIdleImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$HabitCreateIdleImpl implements HabitCreateIdle {
  const _$HabitCreateIdleImpl();

  @override
  String toString() {
    return 'HabitCreateState.idle()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$HabitCreateIdleImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() idle,
    required TResult Function() progress,
    required TResult Function() success,
    required TResult Function() error,
  }) {
    return idle();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? idle,
    TResult? Function()? progress,
    TResult? Function()? success,
    TResult? Function()? error,
  }) {
    return idle?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? idle,
    TResult Function()? progress,
    TResult Function()? success,
    TResult Function()? error,
    required TResult orElse(),
  }) {
    if (idle != null) {
      return idle();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(HabitCreateIdle value) idle,
    required TResult Function(HabitCreateProgress value) progress,
    required TResult Function(HabitCreateSuccess value) success,
    required TResult Function(HabitCreateError value) error,
  }) {
    return idle(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(HabitCreateIdle value)? idle,
    TResult? Function(HabitCreateProgress value)? progress,
    TResult? Function(HabitCreateSuccess value)? success,
    TResult? Function(HabitCreateError value)? error,
  }) {
    return idle?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(HabitCreateIdle value)? idle,
    TResult Function(HabitCreateProgress value)? progress,
    TResult Function(HabitCreateSuccess value)? success,
    TResult Function(HabitCreateError value)? error,
    required TResult orElse(),
  }) {
    if (idle != null) {
      return idle(this);
    }
    return orElse();
  }
}

abstract class HabitCreateIdle implements HabitCreateState {
  const factory HabitCreateIdle() = _$HabitCreateIdleImpl;
}

/// @nodoc
abstract class _$$HabitCreateProgressImplCopyWith<$Res> {
  factory _$$HabitCreateProgressImplCopyWith(_$HabitCreateProgressImpl value,
          $Res Function(_$HabitCreateProgressImpl) then) =
      __$$HabitCreateProgressImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$HabitCreateProgressImplCopyWithImpl<$Res>
    extends _$HabitCreateStateCopyWithImpl<$Res, _$HabitCreateProgressImpl>
    implements _$$HabitCreateProgressImplCopyWith<$Res> {
  __$$HabitCreateProgressImplCopyWithImpl(_$HabitCreateProgressImpl _value,
      $Res Function(_$HabitCreateProgressImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$HabitCreateProgressImpl implements HabitCreateProgress {
  const _$HabitCreateProgressImpl();

  @override
  String toString() {
    return 'HabitCreateState.progress()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$HabitCreateProgressImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() idle,
    required TResult Function() progress,
    required TResult Function() success,
    required TResult Function() error,
  }) {
    return progress();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? idle,
    TResult? Function()? progress,
    TResult? Function()? success,
    TResult? Function()? error,
  }) {
    return progress?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? idle,
    TResult Function()? progress,
    TResult Function()? success,
    TResult Function()? error,
    required TResult orElse(),
  }) {
    if (progress != null) {
      return progress();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(HabitCreateIdle value) idle,
    required TResult Function(HabitCreateProgress value) progress,
    required TResult Function(HabitCreateSuccess value) success,
    required TResult Function(HabitCreateError value) error,
  }) {
    return progress(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(HabitCreateIdle value)? idle,
    TResult? Function(HabitCreateProgress value)? progress,
    TResult? Function(HabitCreateSuccess value)? success,
    TResult? Function(HabitCreateError value)? error,
  }) {
    return progress?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(HabitCreateIdle value)? idle,
    TResult Function(HabitCreateProgress value)? progress,
    TResult Function(HabitCreateSuccess value)? success,
    TResult Function(HabitCreateError value)? error,
    required TResult orElse(),
  }) {
    if (progress != null) {
      return progress(this);
    }
    return orElse();
  }
}

abstract class HabitCreateProgress implements HabitCreateState {
  const factory HabitCreateProgress() = _$HabitCreateProgressImpl;
}

/// @nodoc
abstract class _$$HabitCreateSuccessImplCopyWith<$Res> {
  factory _$$HabitCreateSuccessImplCopyWith(_$HabitCreateSuccessImpl value,
          $Res Function(_$HabitCreateSuccessImpl) then) =
      __$$HabitCreateSuccessImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$HabitCreateSuccessImplCopyWithImpl<$Res>
    extends _$HabitCreateStateCopyWithImpl<$Res, _$HabitCreateSuccessImpl>
    implements _$$HabitCreateSuccessImplCopyWith<$Res> {
  __$$HabitCreateSuccessImplCopyWithImpl(_$HabitCreateSuccessImpl _value,
      $Res Function(_$HabitCreateSuccessImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$HabitCreateSuccessImpl implements HabitCreateSuccess {
  const _$HabitCreateSuccessImpl();

  @override
  String toString() {
    return 'HabitCreateState.success()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$HabitCreateSuccessImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() idle,
    required TResult Function() progress,
    required TResult Function() success,
    required TResult Function() error,
  }) {
    return success();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? idle,
    TResult? Function()? progress,
    TResult? Function()? success,
    TResult? Function()? error,
  }) {
    return success?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? idle,
    TResult Function()? progress,
    TResult Function()? success,
    TResult Function()? error,
    required TResult orElse(),
  }) {
    if (success != null) {
      return success();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(HabitCreateIdle value) idle,
    required TResult Function(HabitCreateProgress value) progress,
    required TResult Function(HabitCreateSuccess value) success,
    required TResult Function(HabitCreateError value) error,
  }) {
    return success(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(HabitCreateIdle value)? idle,
    TResult? Function(HabitCreateProgress value)? progress,
    TResult? Function(HabitCreateSuccess value)? success,
    TResult? Function(HabitCreateError value)? error,
  }) {
    return success?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(HabitCreateIdle value)? idle,
    TResult Function(HabitCreateProgress value)? progress,
    TResult Function(HabitCreateSuccess value)? success,
    TResult Function(HabitCreateError value)? error,
    required TResult orElse(),
  }) {
    if (success != null) {
      return success(this);
    }
    return orElse();
  }
}

abstract class HabitCreateSuccess implements HabitCreateState {
  const factory HabitCreateSuccess() = _$HabitCreateSuccessImpl;
}

/// @nodoc
abstract class _$$HabitCreateErrorImplCopyWith<$Res> {
  factory _$$HabitCreateErrorImplCopyWith(_$HabitCreateErrorImpl value,
          $Res Function(_$HabitCreateErrorImpl) then) =
      __$$HabitCreateErrorImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$HabitCreateErrorImplCopyWithImpl<$Res>
    extends _$HabitCreateStateCopyWithImpl<$Res, _$HabitCreateErrorImpl>
    implements _$$HabitCreateErrorImplCopyWith<$Res> {
  __$$HabitCreateErrorImplCopyWithImpl(_$HabitCreateErrorImpl _value,
      $Res Function(_$HabitCreateErrorImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$HabitCreateErrorImpl implements HabitCreateError {
  const _$HabitCreateErrorImpl();

  @override
  String toString() {
    return 'HabitCreateState.error()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$HabitCreateErrorImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() idle,
    required TResult Function() progress,
    required TResult Function() success,
    required TResult Function() error,
  }) {
    return error();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? idle,
    TResult? Function()? progress,
    TResult? Function()? success,
    TResult? Function()? error,
  }) {
    return error?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? idle,
    TResult Function()? progress,
    TResult Function()? success,
    TResult Function()? error,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(HabitCreateIdle value) idle,
    required TResult Function(HabitCreateProgress value) progress,
    required TResult Function(HabitCreateSuccess value) success,
    required TResult Function(HabitCreateError value) error,
  }) {
    return error(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(HabitCreateIdle value)? idle,
    TResult? Function(HabitCreateProgress value)? progress,
    TResult? Function(HabitCreateSuccess value)? success,
    TResult? Function(HabitCreateError value)? error,
  }) {
    return error?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(HabitCreateIdle value)? idle,
    TResult Function(HabitCreateProgress value)? progress,
    TResult Function(HabitCreateSuccess value)? success,
    TResult Function(HabitCreateError value)? error,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(this);
    }
    return orElse();
  }
}

abstract class HabitCreateError implements HabitCreateState {
  const factory HabitCreateError() = _$HabitCreateErrorImpl;
}
